(* DataTwist Language Grammar *)
(* Based on Instaparse EBNF syntax *)
(* Handles pipeline-based functional data processing language *)

(* ============= TOP LEVEL STRUCTURE ============= *)

program = comment* (indented-pipeline / function-def / assignment / statement (<opt-ws> (<';'> / newline / comment) <opt-ws> (indented-pipeline / function-def / assignment / statement))* / statement / <opt-ws>) comment*
non-indented-start = #'(?:(?![ \t]{2,}).)' / indented-pipeline-op

(* Terminals *)
integer = #'-?[0-9]+'
identifier = user-identifier
user-identifier = #'(?!(?:true|false|nil)$)[a-zA-Z][a-zA-Z0-9\-_]*[?]?'

(* Literals *)
boolean = 'true' | 'false'
nil = 'nil'
ws = #'[ \t]+'
<opt-ws> = #'[ \t]*'
newline = #'\r?\n'
indent = #'[ \t]{2,}'
regular-char = #'[^\"]'

(* ============= COMMENTS ============= *)

(* Single-line comment: ;; this is a comment *)
single-line-comment = ';;' #'[^\r\n]*'

(* Multi-line comment: (comment content...) *)
multi-line-comment = <'('> <'comment'> <opt-ws> comment-content <')'>
comment-content = #'[^(^)]*' | comment-content <'('> comment-content <')'> comment-content

<comment> = single-line-comment / multi-line-comment

(* ============= STATEMENTS ============= *)

<statement> = function-call | indented-pipeline | <assignment> | <function-def> | try-catch | comment | expr
indented-pipeline = pipeline-source newline indented-pipeline-body
indented-pipeline-body = indented-pipeline-ops pipeline-ending?
indented-pipeline-ops = (indented-pipeline-op / comment) (newline (indented-pipeline-op / comment))*
pipeline-ending = newline indented-closing-brace
indented-closing-brace = indent <'}'>






indented-general-function-call = indent general-function-call

(* Assignment: name = expression *)
assignment = user-identifier <opt-ws> <'='> <opt-ws> expr

(* Function definition: name = [params -> body] *)
function-def = user-identifier <opt-ws> <'='> <opt-ws> function

(* ============= EXPRESSIONS ============= *)

(* Expression precedence (from lowest to highest *)
expr = logical-expr
<logical-expr> = in-expr (<opt-ws> ('and' | 'or') <opt-ws> in-expr)*
<in-expr> = comparison-expr (<opt-ws> 'in' <opt-ws> list)?
<comparison-expr> = arithmetic-expr (<opt-ws> comparison-op <opt-ws> arithmetic-expr)*
<arithmetic-expr> = term (<opt-ws> <'+'> <opt-ws> term | <opt-ws> <'-'> <opt-ws> term)*
<term> = factor (<opt-ws> <'*'> <opt-ws> factor | <opt-ws> <'/'> <opt-ws> factor | <opt-ws> <'%'> <opt-ws> factor)*
<factor> = boolean | nil | literal | function-call | object | function | list | wildcard-access | try-catch | <'('> expr <')'> | identifier

(* Filter condition - expression without pipelines *)
filter-condition = expr

(* Comparison operators  *)
comparison-op = '>' | '<' | '>=' | '<=' | '==' | '!=' | '='

(* Logical operators *)
logical-op = 'and' | 'or'

(* ============= LITERALS ============= *)

literal = boolean | nil | string | number



(* String literals with escaped quotes support *)
string = <'\"'> (escaped-char | regular-char)* <'\"'>
escaped-char = '\\\"' | '\\\\' | <'\\\\'> #'.'

(* Numbers (integer and float) *)
number = integer ('.' integer)?

(* ============= DATA STRUCTURES ============= *)

(* Objects: {key: value key2: value2} (no commas) *)
object = single-line-object / multi-line-object

(* Single line object *)
single-line-object = <'{'> <opt-ws> object-fields <opt-ws> <'}'>
<object-fields> = field (<opt-ws> (field / comment))* | comment* | #''

(* Multi line object *)
multi-line-object = <'{'> newline object-fields-multiline (newline <'}'>)?
<object-fields-multiline> = (object-field-multiline / comment) (<newline> (object-field-multiline / comment))*
object-field-multiline = indent (field-with-multiline-object / field)

(* Field definitions *)
field = user-identifier <opt-ws> <':'> <opt-ws> field-value
field-with-multiline-object = user-identifier <opt-ws> <':'> <opt-ws> multi-line-object
field-value = multi-line-object / same-line-field-value / multi-line-field-value / field-multi-line-object
field-multi-line-object = <'{'> newline object-fields-multiline (newline <'}'>)?
same-line-field-value = expr / multi-line-object / same-line-field-pipeline
same-line-field-pipeline = pipeline-source <ws> pipeline-op (<ws> pipeline-op)*
multi-line-field-value = newline <indent> (pattern-clauses / field-pipeline / comment)

(* Pipeline as field value *)
field-pipeline = expr newline field-pipeline-ops
field-pipeline-ops = indented-pipeline-op (newline indented-pipeline-op)* / indented-pipeline-op

(* Lists: [item1 item2 item3] (no commas) *)
list = single-line-list / multi-line-list

(* Single line list *)
single-line-list = <'['> <opt-ws> list-elements <opt-ws> <']'>
<list-elements> = list-element (<opt-ws> (list-element / comment))* | comment* | #''
list-element = literal | object | list | function | wildcard-access | identifier

(* Multi line list *)
multi-line-list = <'['> newline list-elements-multiline newline <']'>
<list-elements-multiline> = (list-element-multiline / comment) (<newline> (list-element-multiline / comment))*
list-element-multiline = indent expr

(* ============= FUNCTIONS ============= *)

(* Function: [param1 param2 -> body] *)
function = <'['> <opt-ws> function-params <opt-ws> <'->'> <opt-ws> function-body <opt-ws> <']'>
function-params = identifier (<opt-ws> identifier)*
function-body = expr

(* ============= PIPELINES ============= *)

(* Pipeline components *)
pipeline-source = identifier | literal | object | list | wildcard-access
pipeline-op = pipeline-operation / general-function-call

(* Pipeline operations with proper indentation *)
indented-pipeline-op = indent general-function-call | indent specific-pipeline-op

(* Specific pipeline operations *)
specific-pipeline-op = indented-filter-op | indented-map-op | indented-take-op | indented-group-by-op | indented-sum-op | indented-count-op | indented-average-op

(* Built-in pipeline operations *)
indented-filter-op = <'filter'> <opt-ws> operation-arguments
indented-map-op = <'map'> <opt-ws> operation-arguments
indented-take-op = <'take'> <opt-ws> operation-arguments
indented-group-by-op = <'group-by'> <opt-ws> operation-arguments
indented-sum-op = <'sum'> <opt-ws> operation-arguments
indented-count-op = <'count'> <opt-ws> operation-arguments
indented-average-op = <'average'> <opt-ws> operation-arguments

(* Unified pipeline operation: name + optional arguments *)
pipeline-operation = pipeline-name (<opt-ws> operation-arguments)?

(* Pipeline operations - can be built-in or user-defined *)
pipeline-name = identifier

(* Arguments can be expression, object, or nothing *)
operation-arguments = expr / multi-line-object

(* Function calls: func arg1 arg2 or func(arg1, arg2) *)
function-call = user-identifier <opt-ws> (arguments | bare-arguments)

(* General function calls in pipeline context *)
general-function-call = user-identifier <opt-ws> (arguments | bare-arguments)

(* Arguments in parentheses (traditional) *)
arguments = <'('> <opt-ws> (expr (',' <opt-ws> expr)*)? <opt-ws> <')'>

(* Bare arguments (Clojure-style) *)
bare-arguments = expr (<ws> expr)*

(* ============= SPECIAL CONSTRUCTS ============= *)

(* Wildcard access: _.field or _.field.nested or _ *)
wildcard-access = '_' | '_' <'.'> identifier (<'.'> identifier)*

(* Pattern matching as field value: | condition -> result | _ -> default *)
pattern-clauses = pattern-clause ( newline <indent> pattern-clause )*
pattern-clause = '|' <opt-ws> pattern-condition <opt-ws> <'->'> <opt-ws> pattern-result
pattern-condition = pattern-default / pattern-test
pattern-default = <'_'>
pattern-test = expr
pattern-result = expr

(* Try-catch: try expr catch error -> fallback *)
try-catch = <'try'> <opt-ws> expr <opt-ws> <'catch'> <opt-ws> user-identifier <opt-ws> <'->'> <opt-ws> expr

(* ============= END OF INPUT ============= *)



