(* DataTwist Language Grammar *)
(* Based on Instaparse EBNF syntax *)
(* Handles pipeline-based functional data processing language *)

(* ============= TOP LEVEL STRUCTURE ============= *)

program = (statement <opt-ws>*)+ / <opt-ws>

(* Terminals *)
integer = #'[0-9]+'
identifier = #'(?!(?:true|false|nil)$)[a-zA-Z][a-zA-Z0-9\-_]*[?]?'
ws = #'[ \t]+'
<opt-ws> = #'[ \t]*'
ws-with-nl = #'\s+'
<opt-ws-with-nl> = #'\s*'
newline = #'\r?\n'
indent = #'[ \t]{2,}'
regular-char = #'[^\"]'




(* ============= STATEMENTS ============= *)

<statement> = indented-pipeline | assignment | function-def | expr

(* Assignment: name = expression *)
assignment = identifier <opt-ws> <'='> <opt-ws> expr

(* Function definition: name = [params -> body] *)
function-def = identifier <opt-ws> <'='> <opt-ws> function

(* ============= EXPRESSIONS ============= *)

(* Expression precedence (from lowest to highest *)
expr = logical-expr
<logical-expr> = comparison-expr (<'or'> comparison-expr)*
<comparison-expr> = arithmetic-expr (<opt-ws> comparison-op <opt-ws> arithmetic-expr)*
<arithmetic-expr> = term (<opt-ws> <'+'> <opt-ws> term | <opt-ws> <'-'> <opt-ws> term)*
<term> = factor (<opt-ws> <'*'> <opt-ws> factor | <opt-ws> <'/'> <opt-ws> factor | <opt-ws> <'%'> <opt-ws> factor)*
<factor> = boolean | nil | literal | object | list | function | function-call | wildcard-access | try-catch | <'('> expr <')'> | identifier | simple-pipeline | indented-pipeline

(* Filter condition - expression without pipelines *)
filter-condition = filter-expr
<filter-expr> = filter-logical-expr
<filter-logical-expr> = filter-comparison-expr (<'or'> filter-comparison-expr)*
<filter-comparison-expr> = filter-arithmetic-expr (<opt-ws> comparison-op <opt-ws> filter-arithmetic-expr)*
<filter-arithmetic-expr> = filter-term (<opt-ws> <'+'> <opt-ws> filter-term | <opt-ws> <'-'> <opt-ws> filter-term)*
<filter-term> = filter-factor (<opt-ws> <'*'> <opt-ws> filter-factor | <opt-ws> <'/'> <opt-ws> filter-factor | <opt-ws> <'%'> <opt-ws> filter-factor)*
<filter-factor> = boolean | nil | literal | wildcard-access | <'('> filter-condition <')'> | identifier





(* Comparison operators  *)
comparison-op = '>' | '<' | '>=' | '<=' | '==' | '!='

(* Logical operators *)
logical-op = 'and' | 'or'

(* ============= LITERALS ============= *)

literal = string | number

(* Boolean literals *)
boolean = 'true' | 'false'

(* Nil literal  *)
nil = 'nil'

(* String literals with escaped quotes support *)
string = <'\"'> (escaped-char | regular-char)* <'\"'>
escaped-char = '\\\"' | '\\\\' | <'\\\\'> #'.'

(* Numbers (integer and float) *)
number = integer ('.' integer)?



(* ============= IDENTIFIERS ============= *)

(* Identifiers with optional ? suffix for predicates *)
(* Supports letters, numbers, hyphens, underscores *)

(* ============= DATA STRUCTURES ============= *)

(* Objects: {key: value key2: value2} (no commas) *)
object = <'{'> <opt-ws> object-fields <opt-ws> <'}'>
<object-fields> = (field <opt-ws>)*
field = identifier <opt-ws> <':'> <opt-ws> field-value
field = identifier <opt-ws> <':'> <opt-ws> (same-line-field-value / multi-line-field-value)
same-line-field-value = expr
multi-line-field-value = newline <indent> pattern-clauses

(* Lists: [item1 item2 item3] (no commas) *)
list = <'['> <opt-ws> list-elements <opt-ws> <']'>
<list-elements> = (expr <opt-ws>)*

(* ============= FUNCTIONS ============= *)

(* Function: [param1 param2 -> body] *)
function = <'['> <opt-ws> function-params <opt-ws> <'->'> <opt-ws> function-body <opt-ws> <']'>
function-params = identifier (<opt-ws> identifier)*
function-body = expr

(* ============= PIPELINES ============= *)

(* Simple pipeline on single line: data filter condition map transform *)
simple-pipeline = pipeline-source <ws> pipeline-op (<ws> pipeline-op)*
pipeline-op = filter-op / map-op / group-by-op / sort-by-op / take-op / general-function-call
pipeline-operation = pipeline-op | general-function-call
pipeline-source = identifier | literal | object | list | wildcard-access

(* Indented pipeline with newline separation *)
indented-pipeline = pipeline-head indented-ops
pipeline-head = expr
indented-ops = newline indented-pipeline-op+

(* Pipeline operations with proper indentation *)
indented-pipeline-op = indented-filter-op / indented-map-op / indented-group-by-op / indented-sort-by-op / indented-take-op

(* Indented pipeline operations *)
indented-filter-op = indent <'filter'> <ws> filter-expr-content
indented-map-op = indent <'map'> <opt-ws> map-expr-content
indented-group-by-op = indent <'group-by'> <opt-ws> group-by-expr-content
indented-sort-by-op = indent <'sort-by'> <opt-ws> sort-by-expr-content
indented-take-op = indent <'take'> <opt-ws> take-expr-content

(* Expression content for pipeline operations *)
filter-expr-content = #'[^\\n]*'
map-expr-content = #'[^\\n]*'
group-by-expr-content = #'[^\\n]*'
sort-by-expr-content = #'[^\\n]*'
take-expr-content = #'[^\\n]*'

(* Simple expression - without indented pipelines *)
simple-expr = simple-logical-expr
<simple-logical-expr> = simple-comparison-expr (<'or'> simple-comparison-expr)*
<simple-comparison-expr> = simple-arithmetic-expr (<opt-ws> comparison-op <opt-ws> simple-arithmetic-expr)*
<simple-arithmetic-expr> = simple-term (<opt-ws> <'+'> <opt-ws> simple-term | <opt-ws> <'-'> <opt-ws> simple-term)*
<simple-term> = simple-factor (<opt-ws> <'*'> <opt-ws> simple-factor | <opt-ws> <'/'> <opt-ws> simple-factor | <opt-ws> <'%'> <opt-ws> simple-factor)*
<simple-factor> = boolean | nil | literal | object | list | function | function-call | wildcard-access | try-catch | <'('> simple-expr <')'> | identifier | simple-pipeline

(* Specific pipeline operations *)
specific-pipeline-op = filter-op / map-op / group-by-op / sort-by-op / take-op

(* Standard pipeline operations *)
filter-op = <'filter'> <ws> filter-condition
map-op = <'map'> <opt-ws> expr
group-by-op = <'group-by'> <opt-ws> expr
sort-by-op = <'sort-by'> <opt-ws> expr
take-op = <'take'> <opt-ws> expr

(* Pipeline keywords *)
filter-keyword = 'filter'
map-keyword = 'map'
group-by-keyword = 'group-by'
sort-by-keyword = 'sort-by'
take-keyword = 'take'

(* Function calls: func arg1 arg2 or func(arg1, arg2) *)
function-call = identifier <opt-ws> (arguments | bare-arguments)

(* General function calls in pipeline context (explicitly exclude keywords) *)
general-function-call = non-keyword-func
non-keyword-func = <'process'> <opt-ws> (arguments | bare-arguments) | <'transform'> <opt-ws> (arguments | bare-arguments) | <'calculate'> <opt-ws> (arguments | bare-arguments) | <'custom-func'> <opt-ws> (arguments | bare-arguments) | identifier <opt-ws> (arguments | bare-arguments)

(* Arguments in parentheses (traditional) *)
arguments = <'('> <opt-ws> (expr (',' <opt-ws> expr)*)? <opt-ws> <')'>

(* Bare arguments (Clojure-style) *)
bare-arguments = expr (<opt-ws> expr)*

(* ============= SPECIAL CONSTRUCTS ============= *)

(* Wildcard access: _.field or _.field.nested or _ *)
wildcard-access = '_' | '_' <'.'> identifier (<'.'> identifier)*

(* Pattern matching as field value: | condition -> result | _ -> default *)
pattern-clauses = pattern-clause ( newline <indent> pattern-clause )*
pattern-clause = '|' <opt-ws> pattern-condition <opt-ws> <'->'> <opt-ws> pattern-result
pattern-condition = pattern-default / pattern-test
pattern-default = <'_'>
pattern-test = expr
pattern-result = expr

(* Try-catch: try expr catch error -> fallback *)
try-catch = <'try'> <opt-ws> expr <opt-ws> <'catch'> <opt-ws> identifier <opt-ws> <'->'> <opt-ws> expr

(* ============= WHITESPACE AND FORMATTING ============= *)

(* Whitespace handling *)



(* ============= END OF INPUT ============= *)



