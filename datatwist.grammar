(* DataTwist Language Grammar *)
(* Based on Instaparse EBNF syntax *)
(* Handles pipeline-based functional data processing language *)

(* ============= TOP LEVEL STRUCTURE ============= *)

program = statement (newline+ statement)* | #''
non-indented-start = #'(?:(?![ \t]{2,}).)' / indented-pipeline-op

(* Terminals *)
integer = #'[0-9]+'
<identifier> = keyword / user-identifier
keyword = 'filter' | 'map' | 'group-by' | 'sort-by' | 'take' | 'average' | 'sum' | 'count' | 'min' | 'max' | 'process' | 'transform' | 'calculate' | 'custom-func'
user-identifier = #'[a-zA-Z][a-zA-Z0-9\-_]*[?]?'
ws = #'[ \t]+'
<opt-ws> = #'[ \t]*'
newline = #'\r?\n'
indent = #'[ \t]{2,}'
regular-char = #'[^\"]'

(* ============= STATEMENTS ============= *)

<statement> = indented-pipeline | function-call | assignment | function-def | try-catch | expr
indented-pipeline = expr newline indented-pipeline-body
indented-pipeline-body = indented-pipeline-ops pipeline-ending?
indented-pipeline-ops = indented-pipeline-op (newline indented-pipeline-op)*
pipeline-ending = newline indented-closing-brace
indented-closing-brace = indent <'}'>


(* Unified indented pipeline function: indent + operator + optional body *)
indented-pipeline-function = indented-filter-function / indented-arg-aggregation / indented-stream-aggregation

(* Indented filter function with condition *)
indented-filter-function = indent <'filter'> filter-content

(* Indented arg aggregations need content *)
indented-arg-aggregation = indent arg-aggregation-name <opt-ws> indented-aggregation-content

(* Indented stream aggregations work on data *)
indented-stream-aggregation = indent stream-aggregation-name

(* Indented aggregation content *)
indented-aggregation-content = expr / multi-line-object



indented-general-function-call = indent general-function-call

(* Assignment: name = expression *)
assignment = identifier <opt-ws> <'='> <opt-ws> expr

(* Function definition: name = [params -> body] *)
function-def = identifier <opt-ws> <'='> <opt-ws> function

(* ============= EXPRESSIONS ============= *)

(* Expression precedence (from lowest to highest *)
expr = logical-expr
<logical-expr> = comparison-expr (<opt-ws> logical-op <opt-ws> comparison-expr)*
<comparison-expr> = arithmetic-expr (<opt-ws> comparison-op <opt-ws> arithmetic-expr)*
<arithmetic-expr> = term (<opt-ws> <'+'> <opt-ws> term | <opt-ws> <'-'> <opt-ws> term)*
<term> = factor (<opt-ws> <'*'> <opt-ws> factor | <opt-ws> <'/'> <opt-ws> factor | <opt-ws> <'%'> <opt-ws> factor)*
<factor> = function-call | stream-aggregation-function | boolean | nil | literal | object | function | list | wildcard-access | try-catch | <'('> expr <')'> | identifier

(* Filter condition - expression without pipelines *)
filter-condition = expr

(* Comparison operators  *)
comparison-op = '>' | '<' | '>=' | '<=' | '==' | '!='

(* Logical operators *)
logical-op = 'and' | 'or'

(* ============= LITERALS ============= *)

literal = string | number

(* Boolean literals *)
boolean = 'true' | 'false'

(* Nil literal  *)
nil = 'nil'

(* String literals with escaped quotes support *)
string = <'\"'> (escaped-char | regular-char)* <'\"'>
escaped-char = '\\\"' | '\\\\' | <'\\\\'> #'.'

(* Numbers (integer and float) *)
number = integer ('.' integer)?

(* ============= DATA STRUCTURES ============= *)

(* Objects: {key: value key2: value2} (no commas) *)
object = single-line-object / multi-line-object

(* Single line object *)
single-line-object = <'{'> <opt-ws> object-fields <opt-ws> <'}'>
<object-fields> = field (<opt-ws> field)* | #''

(* Multi line object *)
multi-line-object = <'{'> newline object-fields-multiline (newline <'}'>)?
<object-fields-multiline> = object-field-multiline (<newline> object-field-multiline)*
object-field-multiline = indent (field-with-multiline-object / field)

(* Field definitions *)
field = identifier <opt-ws> <':'> <opt-ws> field-value
field-with-multiline-object = identifier <opt-ws> <':'> <opt-ws> multi-line-object
field-value = multi-line-object / same-line-field-value / multi-line-field-value / field-multi-line-object
field-multi-line-object = <'{'> newline object-fields-multiline (newline <'}'>)?
same-line-field-value = expr / multi-line-object / same-line-field-pipeline
same-line-field-pipeline = pipeline-source <ws> pipeline-op (<ws> pipeline-op)*
multi-line-field-value = newline <indent> (pattern-clauses / field-pipeline)

(* Pipeline as field value *)
field-pipeline = expr newline field-pipeline-ops
field-pipeline-ops = indented-pipeline-op (newline indented-pipeline-op)* / indented-pipeline-op

(* Lists: [item1 item2 item3] (no commas) *)
list = single-line-list / multi-line-list

(* Single line list *)
single-line-list = <'['> <opt-ws> list-elements <opt-ws> <']'>
<list-elements> = list-element (<opt-ws> list-element)* | #''
list-element = literal | object | list | function | wildcard-access | identifier

(* Multi line list *)
multi-line-list = <'['> newline list-elements-multiline newline <']'>
<list-elements-multiline> = list-element-multiline (<newline> list-element-multiline)*
list-element-multiline = indent expr

(* ============= FUNCTIONS ============= *)

(* Function: [param1 param2 -> body] *)
function = <'['> <opt-ws> function-params <opt-ws> <'->'> <opt-ws> function-body <opt-ws> <']'>
function-params = identifier (<opt-ws> identifier)*
function-body = expr

(* ============= PIPELINES ============= *)

(* Pipeline components *)
pipeline-source = identifier | literal | object | list | wildcard-access
pipeline-op = pipeline-function / general-function-call

(* Pipeline operations with proper indentation *)
indented-pipeline-op = indented-filter-op / indented-map-op / indented-group-by-op / indented-sort-by-op / indented-take-op / indented-general-function-call

(* Indented pipeline operations *)
indented-filter-op = indent <'filter'> filter-content
indented-map-op = indent <'map'> <opt-ws> map-operation-content
map-operation-content = expr / multi-line-object
indented-group-by-op = indent <'group-by'> <opt-ws> expr-until-newline
indented-sort-by-op = indent <'sort-by'> <opt-ws> expr-until-newline
indented-take-op = indent <'take'> <opt-ws> expr-until-newline
indented-average-op = indent <'average'> <opt-ws> expr-until-newline
indented-general-function-call = indent general-function-call

(* Filter content - can be inline or multiline *)
filter-content = opt-ws filter-content-body
filter-content-body = expr-until-newline / multiline-filter-content

(* Map content - can be inline or multiline *)
map-content = opt-ws (expr-until-newline / multi-line-object)



(* Multiline filter content - capture everything until next pipeline op *)
multiline-filter-content = multiline-filter-line+
multiline-filter-line = newline indent filter-line-content
filter-line-content = #'(?:(?!\\n\\s+(?:filter|map|group-by|sort-by|take|average|sum|count|min|max|process|transform|calculate|custom-func)\\b).)+'

(* Expression that stops at newline *)
expr-until-newline = expr



(* ============= PIPELINE FUNCTIONS ============= *)

(* Built-in pipeline function names - easily extendable list *)
pipeline-function-name = 'filter' | 'map' | 'group-by' | 'sort-by' | 'take' | 'average' | 'sum' | 'count' | 'min' | 'max'

(* Unified pipeline function: operator + optional body *)
pipeline-function = filter-function / arg-aggregation-function / stream-aggregation-function

(* Filter needs condition *)
filter-function = <'filter'> <ws> filter-condition

(* Aggregations that need arguments *)
arg-aggregation-function = arg-aggregation-name <opt-ws> expr

(* Aggregations that work on data stream - optionally with arguments *)
stream-aggregation-function = stream-aggregation-name (<opt-ws> (arguments | bare-arguments))?

(* Functions that need arguments *)
arg-aggregation-name = 'map' | 'group-by' | 'sort-by' | 'take'

(* Functions that work on data stream *)
stream-aggregation-name = 'average' | 'sum' | 'count' | 'min' | 'max'

(* Pipeline keywords for identifier validation - now using unified keyword rule *)
pipeline-keyword = keyword

(* Function calls: func arg1 arg2 or func(arg1, arg2) *)
function-call = identifier <opt-ws> (arguments | bare-arguments)

(* General function calls in pipeline context (only specific allowed functions) *)
general-function-call = non-keyword-func
non-keyword-func = <'process'> <opt-ws> (arguments | bare-arguments) | <'transform'> <opt-ws> (arguments | bare-arguments) | <'calculate'> <opt-ws> (arguments | bare-arguments) | <'custom-func'> <opt-ws> (arguments | bare-arguments) | <'average'> <opt-ws> (arguments | bare-arguments) | <'sum'> <opt-ws> (arguments | bare-arguments) | <'count'> <opt-ws> (arguments | bare-arguments) | <'min'> <opt-ws> (arguments | bare-arguments) | <'max'> <opt-ws> (arguments | bare-arguments)

(* Arguments in parentheses (traditional) *)
arguments = <'('> <opt-ws> (expr (',' <opt-ws> expr)*)? <opt-ws> <')'>

(* Bare arguments (Clojure-style) *)
bare-arguments = expr (<opt-ws> expr)*

(* ============= SPECIAL CONSTRUCTS ============= *)

(* Wildcard access: _.field or _.field.nested or _ *)
wildcard-access = '_' | '_' <'.'> identifier (<'.'> identifier)*

(* Pattern matching as field value: | condition -> result | _ -> default *)
pattern-clauses = pattern-clause ( newline <indent> pattern-clause )*
pattern-clause = '|' <opt-ws> pattern-condition <opt-ws> <'->'> <opt-ws> pattern-result
pattern-condition = pattern-default / pattern-test
pattern-default = <'_'>
pattern-test = expr
pattern-result = expr

(* Try-catch: try expr catch error -> fallback *)
try-catch = <'try'> <opt-ws> expr <opt-ws> <'catch'> <opt-ws> identifier <opt-ws> <'->'> <opt-ws> expr

(* ============= END OF INPUT ============= *)



