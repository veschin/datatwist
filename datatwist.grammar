; DataTwist Language Grammar
; Based on Instaparse EBNF syntax
; Handles pipeline-based functional data processing language

; ============= TOP LEVEL STRUCTURE =============

program = (statement <opt-ws>)* | <opt-ws>

; Terminals
integer = #'[0-9]+'
identifier = #'(?!(?:true|false|nil)$)[a-zA-Z][a-zA-Z0-9\-_]*[?]?'
ws = #'\s+'
<opt-ws> = #'\s*'
newline = #'\r?\n'
indent = #'[ \t]{2,}'
regular-char = #'[^\"]'



; ============= STATEMENTS =============

<statement> = indented-pipeline | simple-pipeline | assignment | function-def | expr

; Assignment: name = expression
assignment = identifier <opt-ws> <'='> <opt-ws> expr

; Function definition: name = [params -> body]
function-def = identifier <opt-ws> <'='> <opt-ws> function

; ============= EXPRESSIONS =============

; Expression precedence (from lowest to highest)
expr = logical-expr
<logical-expr> = comparison-expr (<'or'> comparison-expr)*
<comparison-expr> = arithmetic-expr (<opt-ws> comparison-op <opt-ws> arithmetic-expr)*
<arithmetic-expr> = term (<opt-ws> <'+'> <opt-ws> term | <opt-ws> <'-'> <opt-ws> term)*
<term> = factor (<opt-ws> <'*'> <opt-ws> factor | <opt-ws> <'/'> <opt-ws> factor | <opt-ws> <'%'> <opt-ws> factor)*
<factor> = boolean | nil | literal | object | list | function | wildcard-access | pattern-match | try-catch | <'('> expr <')'> | identifier | simple-pipeline



; Comparison operators  
comparison-op = '>' | '<' | '>=' | '<=' | '==' | '!='

; Logical operators
logical-op = 'and' | 'or'

; ============= LITERALS =============

literal = string | number

; Boolean literals
boolean = 'true' | 'false'

; Nil literal  
nil = 'nil'

; String literals with escaped quotes support
string = <'\"'> (escaped-char | regular-char)* <'\"'>
escaped-char = '\\\"' | '\\\\' | <'\\\\'> #'.'

; Numbers (integer and float)
number = integer ('.' integer)?



; ============= IDENTIFIERS =============

; Identifiers with optional ? suffix for predicates
; Supports letters, numbers, hyphens, underscores

; ============= DATA STRUCTURES =============

; Objects: {key: value key2: value2} (no commas)
object = <'{'> <opt-ws> object-fields <opt-ws> <'}'>
<object-fields> = (field <opt-ws>)*
field = identifier <opt-ws> <':'> <opt-ws> expr

; Lists: [item1 item2 item3] (no commas)
list = <'['> <opt-ws> list-elements <opt-ws> <']'>
<list-elements> = (expr <opt-ws>)*

; ============= FUNCTIONS =============

; Function: [param1 param2 -> body]
function = <'['> <opt-ws> function-params <opt-ws> <'->'> <opt-ws> function-body <opt-ws> <']'>
function-params = identifier (<opt-ws> identifier)*
function-body = expr

; ============= PIPELINES =============

; Simple pipeline on single line: data filter condition map transform
simple-pipeline = pipeline-source ws pipeline-keyword-op (<opt-ws> pipeline-keyword-op)*
pipeline-keyword-op = filter-op | map-op | group-by-op | sort-by-op | take-op | general-function-call
pipeline-operation = pipeline-keyword-op | general-function-call
pipeline-source = identifier | literal | object | list | wildcard-access

; Indented pipeline with newline separation
indented-pipeline = pipeline-head indented-ops
pipeline-head = expr
indented-ops = newline indented-pipeline-op+

; Pipeline operations with proper indentation
indented-pipeline-op = indent specific-pipeline-op

; Specific pipeline operations
specific-pipeline-op = filter-op | map-op | group-by-op | sort-by-op | take-op

; Standard pipeline operations
filter-op = <'filter'> ws expr
map-op = <'map'> ws expr
group-by-op = <'group-by'> ws expr
sort-by-op = <'sort-by'> ws expr
take-op = <'take'> ws expr

; Function calls: func arg1 arg2 or func(arg1, arg2)
function-call = identifier ws (arguments | bare-arguments)

; General function calls in pipeline context (explicitly exclude keywords)
general-function-call = non-keyword-func
non-keyword-func = <'process'> ws (arguments | bare-arguments) | <'transform'> ws (arguments | bare-arguments) | <'calculate'> ws (arguments | bare-arguments) | <'custom-func'> ws (arguments | bare-arguments) | identifier ws (arguments | bare-arguments)

; Arguments in parentheses (traditional)
arguments = <'('> <opt-ws> (expr (',' <opt-ws> expr)*)? <opt-ws> <')'>

; Bare arguments (Clojure-style)
bare-arguments = expr (ws expr)*

; ============= SPECIAL CONSTRUCTS =============

; Wildcard access: _.field or _.field.nested or _
wildcard-access = '_' | '_' <'.'> identifier (<'.'> identifier)*

; Pattern matching: expr -> | condition -> result | _ -> default
pattern-match = expr <opt-ws> <'->'> <opt-ws> guard-patterns
guard-patterns = guard-pattern ( '|' <opt-ws> guard-pattern)*
guard-pattern = condition <opt-ws> <'->'> <opt-ws> expr
condition = expr

; Try-catch: try expr catch error -> fallback
try-catch = <'try'> <opt-ws> expr <opt-ws> <'catch'> <opt-ws> identifier <opt-ws> <'->'> <opt-ws> expr

; ============= WHITESPACE AND FORMATTING =============

; Whitespace handling



; ============= END OF INPUT =============



# ============= GRAMMAR NOTES =============
# 
# Key design decisions:
# 1. No comma separators in objects/lists (space-separated)
# 2. Indentation-based pipelines for readability
# 3. Wildcard access with _.field syntax
# 4. Guard patterns with | condition -> result
# 5. Nil-tolerant field access (no error on missing fields)
# 6. Function calls support both parentheses and bare arguments
# 7. Pipeline operations can be chained on single line or indented
# 8. Pattern matching supports when clauses through guard conditions
#
# Performance considerations:
# - Use string literals instead of regex for fixed tokens
# - Use quantifiers (+, *) instead of recursion where possible
# - Hide intermediate nodes with <> for cleaner parse trees
# - Use ordered choice (/) for keyword vs identifier disambiguation