(* DataTwist Language Grammar *)
(* Based on Instaparse EBNF syntax *)
(* Handles pipeline-based functional data processing language *)

(* ============= TOP LEVEL STRUCTURE ============= *)

program = (statement <opt-ws>*)+ / <opt-ws>

(* Terminals *)
integer = #'[0-9]+'
identifier = #'(?!(?:true|false|nil)$)[a-zA-Z][a-zA-Z0-9\-_]*[?]?'
ws = #'[ \t]+'
<opt-ws> = #'[ \t]*'
ws-with-nl = #'\s+'
<opt-ws-with-nl> = #'\s*'
newline = #'\r?\n'
indent = #'[ \t]{2,}'
regular-char = #'[^\"]'




(* ============= STATEMENTS ============= *)

<statement> = function-call | indented-pipeline | assignment | function-def | try-catch | expr

(* Assignment: name = expression *)
assignment = identifier <opt-ws> <'='> <opt-ws> expr

(* Function definition: name = [params -> body] *)
function-def = identifier <opt-ws> <'='> <opt-ws> function

(* ============= EXPRESSIONS ============= *)

(* Expression precedence (from lowest to highest *)
expr = logical-expr
<logical-expr> = comparison-expr (<opt-ws> logical-op <opt-ws> comparison-expr)*
<comparison-expr> = arithmetic-expr (<opt-ws> comparison-op <opt-ws> arithmetic-expr)*
<arithmetic-expr> = term (<opt-ws> <'+'> <opt-ws> term | <opt-ws> <'-'> <opt-ws> term)*
<term> = factor (<opt-ws> <'*'> <opt-ws> factor | <opt-ws> <'/'> <opt-ws> factor | <opt-ws> <'%'> <opt-ws> factor)*
<factor> = function-call | boolean | nil | literal | object | function | list | wildcard-access | try-catch | <'('> expr <')'> | identifier

(* Filter condition - expression without pipelines *)
filter-condition = filter-expr
<filter-expr> = filter-logical-expr
<filter-logical-expr> = filter-comparison-expr (<'or'> filter-comparison-expr)*
<filter-comparison-expr> = filter-arithmetic-expr (<opt-ws> comparison-op <opt-ws> filter-arithmetic-expr)*
<filter-arithmetic-expr> = filter-term (<opt-ws> <'+'> <opt-ws> filter-term | <opt-ws> <'-'> <opt-ws> filter-term)*
<filter-term> = filter-factor (<opt-ws> <'*'> <opt-ws> filter-factor | <opt-ws> <'/'> <opt-ws> filter-factor | <opt-ws> <'%'> <opt-ws> filter-factor)*
<filter-factor> = boolean | nil | literal | wildcard-access | <'('> filter-condition <')'> | identifier





(* Comparison operators  *)
comparison-op = '>' | '<' | '>=' | '<=' | '==' | '!='

(* Logical operators *)
logical-op = 'and' | 'or'

(* ============= LITERALS ============= *)

literal = string | number

(* Boolean literals *)
boolean = 'true' | 'false'

(* Nil literal  *)
nil = 'nil'

(* String literals with escaped quotes support *)
string = <'\"'> (escaped-char | regular-char)* <'\"'>
escaped-char = '\\\"' | '\\\\' | <'\\\\'> #'.'

(* Numbers (integer and float) *)
number = integer ('.' integer)?



(* ============= IDENTIFIERS ============= *)

(* Identifiers with optional ? suffix for predicates *)
(* Supports letters, numbers, hyphens, underscores *)

(* ============= DATA STRUCTURES ============= *)

(* Objects: {key: value key2: value2} (no commas) *)
object = single-line-object / multi-line-object

(* Single line object *)
single-line-object = <'{'> <opt-ws> object-fields <opt-ws> <'}'>
<object-fields> = (field <opt-ws>)*

(* Multi line object *)
multi-line-object = <'{'> newline object-fields-multiline newline <'}'>
<object-fields-multiline> = object-field-multiline (<newline> object-field-multiline)*
object-field-multiline = indent field

(* Field definitions *)
field = identifier <opt-ws> <':'> <opt-ws> field-value
field-value = same-line-field-value / multi-line-field-value
same-line-field-value = expr / same-line-field-pipeline
same-line-field-pipeline = pipeline-source <ws> pipeline-op (<ws> pipeline-op)*
multi-line-field-value = newline <indent> (pattern-clauses / field-pipeline)

(* Pipeline as field value *)
field-pipeline = simple-expr newline field-pipeline-ops
field-pipeline-ops = indented-first-op remaining-ops / indented-first-op

(* Lists: [item1 item2 item3] (no commas) *)
list = single-line-list / multi-line-list

(* Single line list *)
single-line-list = <'['> <opt-ws> list-elements <opt-ws> <']'>
<list-elements> = (expr <opt-ws>)*

(* Multi line list *)
multi-line-list = <'['> newline list-elements-multiline newline <']'>
<list-elements-multiline> = list-element-multiline (<newline> list-element-multiline)*
list-element-multiline = indent expr

(* ============= FUNCTIONS ============= *)

(* Function: [param1 param2 -> body] *)
function = <'['> <opt-ws> function-params <opt-ws> <'->'> <opt-ws> function-body <opt-ws> <']'>
function-params = identifier (<opt-ws> identifier)*
function-body = expr

(* ============= PIPELINES ============= *)

(* Pipeline components *)
pipeline-source = identifier | literal | object | list | wildcard-access
pipeline-op = filter-op / map-op / group-by-op / sort-by-op / take-op / general-function-call



(* Indented pipeline with newline separation *)
indented-pipeline = pipeline-head newline indented-first-op remaining-ops
pipeline-head = expr
indented-first-op = indented-pipeline-op
remaining-ops = (newline indented-pipeline-op)*

(* Pipeline operations with proper indentation *)
indented-pipeline-op = indented-filter-op / indented-map-op / indented-group-by-op / indented-sort-by-op / indented-take-op / indented-general-function-call

(* Indented pipeline operations *)
indented-filter-op = indent <'filter'> filter-content
indented-map-op = indent <'map'> <opt-ws> expr
indented-group-by-op = indent <'group-by'> <opt-ws> expr-until-newline
indented-sort-by-op = indent <'sort-by'> <opt-ws> expr-until-newline
indented-take-op = indent <'take'> <opt-ws> expr-until-newline
indented-general-function-call = indent general-function-call

(* Filter content - can be inline or multiline *)
filter-content = opt-ws filter-content-body
filter-content-body = expr-until-newline / multiline-filter-content

(* Multiline filter content - capture everything until next pipeline op *)
multiline-filter-content = multiline-filter-line+
multiline-filter-line = newline indent filter-line-content
filter-line-content = #'(?:(?!\\n\\s+(?:filter|map|group-by|sort-by|take|process|transform|calculate|custom-func)\\b).)+'

(* Expression that stops at newline *)
expr-until-newline = logical-expr-until-newline
<logical-expr-until-newline> = comparison-expr-until-newline (<opt-ws> <'and'> <opt-ws> comparison-expr-until-newline | <'or'> comparison-expr-until-newline)*
<comparison-expr-until-newline> = arithmetic-expr-until-newline (<opt-ws> comparison-op <opt-ws> arithmetic-expr-until-newline)*
<arithmetic-expr-until-newline> = term-until-newline (<opt-ws> <'+'> <opt-ws> term-until-newline | <opt-ws> <'-'> <opt-ws> term-until-newline)*
<term-until-newline> = factor-until-newline (<opt-ws> <'*'> <opt-ws> factor-until-newline | <opt-ws> <'/'> <opt-ws> factor-until-newline | <opt-ws> <'%'> <opt-ws> factor-until-newline)*
<factor-until-newline> = boolean | nil | literal | string | object | list | function | function-call | wildcard-access | try-catch | <'('> expr-until-newline <')'> | identifier

(* Expression content for pipeline operations *)
filter-expr-content = simple-expr
map-expr-content = simple-expr
group-by-expr-content = simple-expr
sort-by-expr-content = simple-expr
take-expr-content = simple-expr

(* Simple expression - without indented pipelines *)
simple-expr = simple-logical-expr
<simple-logical-expr> = simple-comparison-expr (<'or'> simple-comparison-expr)*
<simple-comparison-expr> = simple-arithmetic-expr (<opt-ws> comparison-op <opt-ws> simple-arithmetic-expr)*
<simple-arithmetic-expr> = simple-term (<opt-ws> <'+'> <opt-ws> simple-term | <opt-ws> <'-'> <opt-ws> simple-term)*
<simple-term> = simple-factor (<opt-ws> <'*'> <opt-ws> simple-factor | <opt-ws> <'/'> <opt-ws> simple-factor | <opt-ws> <'%'> <opt-ws> simple-factor)*
<simple-factor> = boolean | nil | literal | object | list | function | function-call | wildcard-access | try-catch | <'('> simple-expr <')'> | identifier

(* Specific pipeline operations *)
specific-pipeline-op = filter-op / map-op / group-by-op / sort-by-op / take-op

(* Standard pipeline operations *)
filter-op = <'filter'> <ws> filter-condition
map-op = <'map'> <opt-ws> expr
group-by-op = <'group-by'> <opt-ws> expr
sort-by-op = <'sort-by'> <opt-ws> expr
take-op = <'take'> <opt-ws> expr

(* Pipeline keywords *)
filter-keyword = 'filter'
map-keyword = 'map'
group-by-keyword = 'group-by'
sort-by-keyword = 'sort-by'
take-keyword = 'take'

(* Function calls: func arg1 arg2 or func(arg1, arg2) *)
function-call = identifier <opt-ws> (arguments | bare-arguments)

(* General function calls in pipeline context (only specific allowed functions) *)
general-function-call = non-keyword-func
non-keyword-func = <'process'> <opt-ws> (arguments | bare-arguments) | <'transform'> <opt-ws> (arguments | bare-arguments) | <'calculate'> <opt-ws> (arguments | bare-arguments) | <'custom-func'> <opt-ws> (arguments | bare-arguments)

(* Arguments in parentheses (traditional) *)
arguments = <'('> <opt-ws> (expr (',' <opt-ws> expr)*)? <opt-ws> <')'>

(* Bare arguments (Clojure-style) *)
bare-arguments = expr (<opt-ws> expr)*

(* ============= SPECIAL CONSTRUCTS ============= *)

(* Wildcard access: _.field or _.field.nested or _ *)
wildcard-access = '_' | '_' <'.'> identifier (<'.'> identifier)*

(* Pattern matching as field value: | condition -> result | _ -> default *)
pattern-clauses = pattern-clause ( newline <indent> pattern-clause )*
pattern-clause = '|' <opt-ws> pattern-condition <opt-ws> <'->'> <opt-ws> pattern-result
pattern-condition = pattern-default / pattern-test
pattern-default = <'_'>
pattern-test = expr
pattern-result = expr

(* Try-catch: try expr catch error -> fallback *)
try-catch = <'try'> <opt-ws> expr <opt-ws> <'catch'> <opt-ws> identifier <opt-ws> <'->'> <opt-ws> expr

(* ============= WHITESPACE AND FORMATTING ============= *)

(* Whitespace handling *)



(* ============= END OF INPUT ============= *)



